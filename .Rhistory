if (length(hits) == 0) return(NA_character_)
first <- hits[1]
cat(paste0("  [1] ", first, "\n"))
to_unc(first)
}
temp_path <- list_and_normalize(kaggle_dir, "TEMP.tif$", "TEMP")
pop_path  <- list_and_normalize(kaggle_dir, "GHS_POP_E2015_GLOBE_R2019A_54009_250_V1_0\\.tif$", "POP")
veg_path  <- list_and_normalize(kaggle_dir, "ESACCI-LC-L4-LCCS-Map-300m-P1Y-2015-v2\\.0\\.7\\.tif$", "VEG")
haz_path  <- list_and_normalize(kaggle_dir, "Goode_FinalClassification_19_05pcnt_prj\\.tif$", "HAZ")
gdp_path  <- list_and_normalize(kaggle_dir, "GDP_PPP_1990_2015_5arcmin_v2\\.nc$", "GDP")
# Explicit override for temperature path if auto-discovery fails (UNC Windows path)
if (is.na(temp_path) || !file.exists(temp_path)) {
temp_path <- to_unc(
file.path(
windows_root, "data", "Kaggle Dataset", "11_temperature",
"World_TEMP_GISdata_LTAy_GlobalSolarAtlas-v2_GEOTIFF",
"World_TEMP_GISdata_LTAy_GlobalSolarAtlas_GEOTIFF",
"TEMP.tif"
)
)
}
cat("Resolved temp_path:", temp_path, "exists:", file.exists(temp_path), "\n")
cat("Resolved pop_path :", pop_path,  "exists:", file.exists(pop_path),  "\n")
cat("Resolved veg_path :", veg_path,  "exists:", file.exists(veg_path),  "\n")
cat("Resolved haz_path :", haz_path,  "exists:", file.exists(haz_path),  "\n")
cat("Resolved gdp_path :", gdp_path,  "exists:", file.exists(gdp_path),  "\n")
if (is.na(temp_path) || !file.exists(temp_path)) stop("Temperature raster not found or unreadable; ensure TEMP.tif exists and the path is accessible.")
if (is.na(pop_path)  || !file.exists(pop_path))  stop("Population raster not found or unreadable; ensure GHS_POP...tif exists and the path is accessible.")
env_static <- world %>%
transmute(country_iso) %>%
left_join(
extract_stat(world, temp_path, fun = "mean", fact = 40) %>%
rename(temp_celsius = value),
by = "country_iso"
) %>%
left_join(
extract_stat(world, pop_path, fun = "sum", fact = 60) %>%  # POP is huge
rename(population = value),
by = "country_iso"
) %>%
left_join({
if (file.exists(veg_path)) {
r <- rast(veg_path)
if (crs(r) != crs(world)) world_aligned <- st_transform(world, ̥crs(r)) else world_aligned <- world
world <- rnaturalearth::ne_countries(scale = "medium", returnclass = "sf") %>%
mutate(country_iso = toupper(iso_a3)) %>%
filter(country_iso != "-99") %>%
select(country_iso, geometry)
plot(st_geometry(world))
extract_stat <- function(shapes, raster_path, fun = "mean", band = 1,
fact = 40,      # more aggressive downsampling
use_zonal = TRUE) {
if (!file.exists(raster_path)) {
warning("Missing raster: ", raster_path)
return(tibble(country_iso = shapes$country_iso, value = NA_real_))
}
# Load single band only to avoid loading full stack
r <- rast(raster_path)
if (band > nlyr(r)) stop("Band ", band, " not in raster.")
r <- r[[band]]
# Align CRS
if (!is.na(crs(r)) && crs(r) != crs(shapes)) {
shapes <- st_transform(shapes, crs(r))
}
# Crop early
r <- crop(r, vect(shapes))
# Heavy downsample to save RAM
r <- aggregate(
r, fact = fact, fun = mean, na.rm = TRUE,
filename = tempfile(fileext = ".tif"), overwrite = TRUE
)
shapes$id <- seq_len(nrow(shapes))
if (use_zonal) {
z <- tryCatch(
terra::zonal(r, vect(shapes), fun = fun, na.rm = TRUE),
error = function(e) NULL
)
if (!is.null(z)) {
vals <- rep(NA_real_, nrow(shapes))
vals[match(z$zone, shapes$id)] <- z[[ncol(z)]]
return(tibble(country_iso = shapes$country_iso, value = vals))
}
}
ex <- terra::extract(r, vect(shapes), fun = match.fun(fun), na.rm = TRUE)
vals <- ex[, 2]
tibble(country_iso = shapes$country_iso, value = vals)
}
temp_path <- "data/Kaggle Dataset/11_temperature/World_TEMP_GISdata_LTAy_GlobalSolarAtlas-v2_GEOTIFF/World_TEMP_GISdata_LTAy_GlobalSolarAtlas_GEOTIFF/TEMP.tif"
print(temp_path)
file.exists(temp_path)
list_and_normalize <- function(dir, pattern, label) {
hits <- list.files(dir, pattern = pattern, recursive = TRUE, full.names = TRUE)
cat(label, "candidates found:", length(hits), "\n")
if (length(hits) == 0) return(NA_character_)
first <- hits[1]
cat(paste0("  [1] ", first, "\n"))
to_unc(first)
}
temp_path <- list_and_normalize(kaggle_dir, "TEMP.tif$", "TEMP")
pop_path  <- list_and_normalize(kaggle_dir, "GHS_POP_E2015_GLOBE_R2019A_54009_250_V1_0\\.tif$", "POP")
veg_path  <- list_and_normalize(kaggle_dir, "ESACCI-LC-L4-LCCS-Map-300m-P1Y-2015-v2\\.0\\.7\\.tif$", "VEG")
haz_path  <- list_and_normalize(kaggle_dir, "Goode_FinalClassification_19_05pcnt_prj\\.tif$", "HAZ")
gdp_path  <- list_and_normalize(kaggle_dir, "GDP_PPP_1990_2015_5arcmin_v2\\.nc$", "GDP")
# Explicit override for temperature path if auto-discovery fails (UNC Windows path)
if (is.na(temp_path) || !file.exists(temp_path)) {
temp_path <- to_unc(
file.path(
windows_root, "data", "Kaggle Dataset", "11_temperature",
"World_TEMP_GISdata_LTAy_GlobalSolarAtlas-v2_GEOTIFF",
"World_TEMP_GISdata_LTAy_GlobalSolarAtlas_GEOTIFF",
"TEMP.tif"
)
)
}
cat("Resolved temp_path:", temp_path, "exists:", file.exists(temp_path), "\n")
cat("Resolved pop_path :", pop_path,  "exists:", file.exists(pop_path),  "\n")
cat("Resolved veg_path :", veg_path,  "exists:", file.exists(veg_path),  "\n")
cat("Resolved haz_path :", haz_path,  "exists:", file.exists(haz_path),  "\n")
cat("Resolved gdp_path :", gdp_path,  "exists:", file.exists(gdp_path),  "\n")
if (is.na(temp_path) || !file.exists(temp_path)) stop("Temperature raster not found or unreadable; ensure TEMP.tif exists and the path is accessible.")
if (is.na(pop_path)  || !file.exists(pop_path))  stop("Population raster not found or unreadable; ensure GHS_POP...tif exists and the path is accessible.")
env_static <- world %>%
transmute(country_iso) %>%
left_join(
extract_stat(world, temp_path, fun = "mean", fact = 40) %>%
rename(temp_celsius = value),
by = "country_iso"
) %>%
left_join(
extract_stat(world, pop_path, fun = "sum", fact = 60) %>%  # POP is huge
rename(population = value),
by = "country_iso"
) %>%
left_join({
if (file.exists(veg_path)) {
r <- rast(veg_path)
if (crs(r) != crs(world)) world_aligned <- st_transform(world, ̥crs(r)) else world_aligned <- world
library(tidyverse)
library(readxl)
library(sf)
library(terra)
library(randomForest)
library(jsonlite)
theme_set(theme_minimal())
# Limit terra memory usage and spill to disk
terraOptions(memfrac = 0.5, todisk = TRUE, parallel = FALSE)
# Set this to your Windows project root (adjust if your drive/folder differs)
windows_root <- "D:/IIT Sem3/Data Preparation and Analysis CSP-571/All project/Impact-of-Environmental-Factors-on-Socioeconomic-Outcomes"
lgii_default <- file.path(windows_root, "data", "Nasa Earth Data", "spatialecon-lgii-measures-v1-xlsx.xlsx")
lgii_sample <- file.path(windows_root, "data", "sample", "lgii_sample.csv")  # set use_sample_lgii <- TRUE only if testing
use_sample_lgii <- FALSE
kaggle_dir <- file.path(windows_root, "data", "Kaggle Dataset")   # adjust if your folder is named differently (e.g., 'data/Kaggle Data')
if (file.exists(lgii_default)) {
lgii_path <- lgii_default
} else if (use_sample_lgii && file.exists(lgii_sample)) {
lgii_path <- lgii_sample
} else {
stop("LGII Excel not found at ", lgii_default, ". Set the correct path or enable use_sample_lgii for the toy CSV.")
}
lgii_path <- normalizePath(lgii_path, winslash = "/", mustWork = TRUE)
kaggle_dir <- normalizePath(kaggle_dir, winslash = "/", mustWork = TRUE)
cat("Using LGII at:", lgii_path, "\n")
cat("Using Kaggle data at:", kaggle_dir, "\n")
standardize_iso <- function(x) toupper(trimws(as.character(x)))
coerce_year <- function(x) suppressWarnings(as.integer(as.character(x)))
zscore <- function(x) {
s <- sd(x, na.rm = TRUE)
m <- mean(x, na.rm = TRUE)
if (is.na(s) || s == 0) return(rep(0, length(x)))
(x - m) / s
}
minmax <- function(x) {
rng <- range(x, na.rm = TRUE)
if (diff(rng) == 0) return(rep(0, length(x)))
(x - rng[1]) / (diff(rng) + 1e-9)
}
to_unc <- function(p) {
if (is.na(p)) return(NA_character_)
paste0("\\\\?\\", normalizePath(p, winslash = "\\", mustWork = FALSE))
}
find_file <- function(base_dir, pattern) {
hits <- list.files(base_dir, pattern = pattern, recursive = TRUE, full.names = TRUE)
if (length(hits) > 0) normalizePath(hits[[1]], winslash = "/", mustWork = FALSE) else NA_character_
}
if (!file.exists(lgii_path)) {
stop("LGII file not found. Checked: ", lgii_path, " and ", lgii_default, ". Place the NASA Excel there or set lgii_path manually.")
}
lgii <- if (grepl("\\.xlsx$", lgii_path, ignore.case = TRUE)) {
lg_raw <- read_excel(lgii_path, sheet = "Data") %>%
janitor::clean_names()
country_col <- intersect(c("iso", "country_iso", "country"), names(lg_raw))
country_col <- if (length(country_col) > 0) country_col[[1]] else NA_character_
gini_col <- intersect(c("gini_weighted", "gini"), names(lg_raw))
gini_col <- if (length(gini_col) > 0) gini_col[[1]] else NA_character_
if (is.na(country_col)) stop("Could not find a country/iso column in LGII.")
lg_raw %>%
mutate(
country_iso = standardize_iso(.data[[country_col]]),
gini = if (!is.na(gini_col)) .data[[gini_col]] else NA_real_
)
} else {
read_csv(lgii_path, show_col_types = FALSE) %>%
janitor::clean_names() %>%
mutate(
country_iso = standardize_iso(coalesce(country_iso, iso, country)),
gini = if ("gini" %in% names(.)) gini else NA_real_
)
}
lgii <- lgii %>%
mutate(
year = coerce_year(year)
) %>%
drop_na(country_iso, year)
glimpse(lgii)
world <- rnaturalearth::ne_countries(scale = "medium", returnclass = "sf") %>%
mutate(country_iso = toupper(iso_a3)) %>%
filter(country_iso != "-99") %>%
select(country_iso, geometry)
plot(st_geometry(world))
extract_stat <- function(shapes, raster_path, fun = "mean", band = 1,
fact = 40,      # more aggressive downsampling
use_zonal = TRUE) {
if (!file.exists(raster_path)) {
warning("Missing raster: ", raster_path)
return(tibble(country_iso = shapes$country_iso, value = NA_real_))
}
# Load single band only to avoid loading full stack
r <- rast(raster_path)
if (band > nlyr(r)) stop("Band ", band, " not in raster.")
r <- r[[band]]
# Align CRS
if (!is.na(crs(r)) && crs(r) != crs(shapes)) {
shapes <- st_transform(shapes, crs(r))
}
# Crop early
r <- crop(r, vect(shapes))
# Heavy downsample to save RAM
r <- aggregate(
r, fact = fact, fun = mean, na.rm = TRUE,
filename = tempfile(fileext = ".tif"), overwrite = TRUE
)
shapes$id <- seq_len(nrow(shapes))
if (use_zonal) {
z <- tryCatch(
terra::zonal(r, vect(shapes), fun = fun, na.rm = TRUE),
error = function(e) NULL
)
if (!is.null(z)) {
vals <- rep(NA_real_, nrow(shapes))
vals[match(z$zone, shapes$id)] <- z[[ncol(z)]]
return(tibble(country_iso = shapes$country_iso, value = vals))
}
}
ex <- terra::extract(r, vect(shapes), fun = match.fun(fun), na.rm = TRUE)
vals <- ex[, 2]
tibble(country_iso = shapes$country_iso, value = vals)
}
temp_path <- "data/Kaggle Dataset/11_temperature/World_TEMP_GISdata_LTAy_GlobalSolarAtlas-v2_GEOTIFF/World_TEMP_GISdata_LTAy_GlobalSolarAtlas_GEOTIFF/TEMP.tif"
print(temp_path)
file.exists(temp_path)
list_and_normalize <- function(dir, pattern, label) {
hits <- list.files(dir, pattern = pattern, recursive = TRUE, full.names = TRUE)
cat(label, "candidates found:", length(hits), "\n")
if (length(hits) == 0) return(NA_character_)
first <- hits[1]
cat(paste0("  [1] ", first, "\n"))
to_unc(first)
}
temp_path <- list_and_normalize(kaggle_dir, "TEMP.tif$", "TEMP")
pop_path  <- list_and_normalize(kaggle_dir, "GHS_POP_E2015_GLOBE_R2019A_54009_250_V1_0\\.tif$", "POP")
veg_path  <- list_and_normalize(kaggle_dir, "ESACCI-LC-L4-LCCS-Map-300m-P1Y-2015-v2\\.0\\.7\\.tif$", "VEG")
haz_path  <- list_and_normalize(kaggle_dir, "Goode_FinalClassification_19_05pcnt_prj\\.tif$", "HAZ")
gdp_path  <- list_and_normalize(kaggle_dir, "GDP_PPP_1990_2015_5arcmin_v2\\.nc$", "GDP")
# Explicit override for temperature path if auto-discovery fails (UNC Windows path)
if (is.na(temp_path) || !file.exists(temp_path)) {
temp_path <- to_unc(
file.path(
windows_root, "data", "Kaggle Dataset", "11_temperature",
"World_TEMP_GISdata_LTAy_GlobalSolarAtlas-v2_GEOTIFF",
"World_TEMP_GISdata_LTAy_GlobalSolarAtlas_GEOTIFF",
"TEMP.tif"
)
)
}
cat("Resolved temp_path:", temp_path, "exists:", file.exists(temp_path), "\n")
cat("Resolved pop_path :", pop_path,  "exists:", file.exists(pop_path),  "\n")
cat("Resolved veg_path :", veg_path,  "exists:", file.exists(veg_path),  "\n")
cat("Resolved haz_path :", haz_path,  "exists:", file.exists(haz_path),  "\n")
cat("Resolved gdp_path :", gdp_path,  "exists:", file.exists(gdp_path),  "\n")
if (is.na(temp_path) || !file.exists(temp_path)) stop("Temperature raster not found or unreadable; ensure TEMP.tif exists and the path is accessible.")
if (is.na(pop_path)  || !file.exists(pop_path))  stop("Population raster not found or unreadable; ensure GHS_POP...tif exists and the path is accessible.")
env_static <- world %>%
transmute(country_iso) %>%
left_join(
extract_stat(world, temp_path, fun = "mean", fact = 40) %>%
rename(temp_celsius = value),
by = "country_iso"
) %>%
left_join(
extract_stat(world, pop_path, fun = "sum", fact = 60) %>%  # POP is huge
rename(population = value),
by = "country_iso"
) %>%
left_join({
if (file.exists(veg_path)) {
r <- rast(veg_path)
if (crs(r) != crs(world)) world_aligned <- st_transform(world, ̥crs(r)) else world_aligned <- world
library(tidyverse)
library(readxl)
library(sf)
library(terra)
library(randomForest)
library(jsonlite)
theme_set(theme_minimal())
# Limit terra memory usage and spill to disk
terraOptions(memfrac = 0.5, todisk = TRUE, parallel = FALSE)
# Set this to your Windows project root (adjust if your drive/folder differs)
windows_root <- "D:/IIT Sem3/Data Preparation and Analysis CSP-571/All project/Impact-of-Environmental-Factors-on-Socioeconomic-Outcomes"
lgii_default <- file.path(windows_root, "data", "Nasa Earth Data", "spatialecon-lgii-measures-v1-xlsx.xlsx")
lgii_sample <- file.path(windows_root, "data", "sample", "lgii_sample.csv")  # set use_sample_lgii <- TRUE only if testing
use_sample_lgii <- FALSE
kaggle_dir <- file.path(windows_root, "data", "Kaggle Dataset")   # adjust if your folder is named differently (e.g., 'data/Kaggle Data')
if (file.exists(lgii_default)) {
lgii_path <- lgii_default
} else if (use_sample_lgii && file.exists(lgii_sample)) {
lgii_path <- lgii_sample
} else {
stop("LGII Excel not found at ", lgii_default, ". Set the correct path or enable use_sample_lgii for the toy CSV.")
}
lgii_path <- normalizePath(lgii_path, winslash = "/", mustWork = TRUE)
kaggle_dir <- normalizePath(kaggle_dir, winslash = "/", mustWork = TRUE)
cat("Using LGII at:", lgii_path, "\n")
cat("Using Kaggle data at:", kaggle_dir, "\n")
standardize_iso <- function(x) toupper(trimws(as.character(x)))
coerce_year <- function(x) suppressWarnings(as.integer(as.character(x)))
zscore <- function(x) {
s <- sd(x, na.rm = TRUE)
m <- mean(x, na.rm = TRUE)
if (is.na(s) || s == 0) return(rep(0, length(x)))
(x - m) / s
}
minmax <- function(x) {
rng <- range(x, na.rm = TRUE)
if (diff(rng) == 0) return(rep(0, length(x)))
(x - rng[1]) / (diff(rng) + 1e-9)
}
to_unc <- function(p) {
if (is.na(p)) return(NA_character_)
paste0("\\\\?\\", normalizePath(p, winslash = "\\", mustWork = FALSE))
}
find_file <- function(base_dir, pattern) {
hits <- list.files(base_dir, pattern = pattern, recursive = TRUE, full.names = TRUE)
if (length(hits) > 0) normalizePath(hits[[1]], winslash = "/", mustWork = FALSE) else NA_character_
}
if (!file.exists(lgii_path)) {
stop("LGII file not found. Checked: ", lgii_path, " and ", lgii_default, ". Place the NASA Excel there or set lgii_path manually.")
}
lgii <- if (grepl("\\.xlsx$", lgii_path, ignore.case = TRUE)) {
lg_raw <- read_excel(lgii_path, sheet = "Data") %>%
janitor::clean_names()
country_col <- intersect(c("iso", "country_iso", "country"), names(lg_raw))
country_col <- if (length(country_col) > 0) country_col[[1]] else NA_character_
gini_col <- intersect(c("gini_weighted", "gini"), names(lg_raw))
gini_col <- if (length(gini_col) > 0) gini_col[[1]] else NA_character_
if (is.na(country_col)) stop("Could not find a country/iso column in LGII.")
lg_raw %>%
mutate(
country_iso = standardize_iso(.data[[country_col]]),
gini = if (!is.na(gini_col)) .data[[gini_col]] else NA_real_
)
} else {
read_csv(lgii_path, show_col_types = FALSE) %>%
janitor::clean_names() %>%
mutate(
country_iso = standardize_iso(coalesce(country_iso, iso, country)),
gini = if ("gini" %in% names(.)) gini else NA_real_
)
}
lgii <- lgii %>%
mutate(
year = coerce_year(year)
) %>%
drop_na(country_iso, year)
glimpse(lgii)
world <- rnaturalearth::ne_countries(scale = "medium", returnclass = "sf") %>%
mutate(country_iso = toupper(iso_a3)) %>%
filter(country_iso != "-99") %>%
select(country_iso, geometry)
plot(st_geometry(world))
extract_stat <- function(shapes, raster_path, fun = "mean", band = 1,
fact = 40,      # more aggressive downsampling
use_zonal = TRUE) {
if (!file.exists(raster_path)) {
warning("Missing raster: ", raster_path)
return(tibble(country_iso = shapes$country_iso, value = NA_real_))
}
# Load single band only to avoid loading full stack
r <- rast(raster_path)
if (band > nlyr(r)) stop("Band ", band, " not in raster.")
r <- r[[band]]
# Align CRS
if (!is.na(crs(r)) && crs(r) != crs(shapes)) {
shapes <- st_transform(shapes, crs(r))
}
# Crop early
r <- crop(r, vect(shapes))
# Heavy downsample to save RAM
r <- aggregate(
r, fact = fact, fun = mean, na.rm = TRUE,
filename = tempfile(fileext = ".tif"), overwrite = TRUE
)
shapes$id <- seq_len(nrow(shapes))
if (use_zonal) {
z <- tryCatch(
terra::zonal(r, vect(shapes), fun = fun, na.rm = TRUE),
error = function(e) NULL
)
if (!is.null(z)) {
vals <- rep(NA_real_, nrow(shapes))
vals[match(z$zone, shapes$id)] <- z[[ncol(z)]]
return(tibble(country_iso = shapes$country_iso, value = vals))
}
}
ex <- terra::extract(r, vect(shapes), fun = match.fun(fun), na.rm = TRUE)
vals <- ex[, 2]
tibble(country_iso = shapes$country_iso, value = vals)
}
temp_path <- "data/Kaggle Dataset/11_temperature/World_TEMP_GISdata_LTAy_GlobalSolarAtlas-v2_GEOTIFF/World_TEMP_GISdata_LTAy_GlobalSolarAtlas_GEOTIFF/TEMP.tif"
print(temp_path)
file.exists(temp_path)
list_and_normalize <- function(dir, pattern, label) {
hits <- list.files(dir, pattern = pattern, recursive = TRUE, full.names = TRUE)
cat(label, "candidates found:", length(hits), "\n")
if (length(hits) == 0) return(NA_character_)
first <- hits[1]
cat(paste0("  [1] ", first, "\n"))
to_unc(first)
}
temp_path <- list_and_normalize(kaggle_dir, "TEMP.tif$", "TEMP")
pop_path  <- list_and_normalize(kaggle_dir, "GHS_POP_E2015_GLOBE_R2019A_54009_250_V1_0\\.tif$", "POP")
veg_path  <- list_and_normalize(kaggle_dir, "ESACCI-LC-L4-LCCS-Map-300m-P1Y-2015-v2\\.0\\.7\\.tif$", "VEG")
haz_path  <- list_and_normalize(kaggle_dir, "Goode_FinalClassification_19_05pcnt_prj\\.tif$", "HAZ")
gdp_path  <- list_and_normalize(kaggle_dir, "GDP_PPP_1990_2015_5arcmin_v2\\.nc$", "GDP")
# Explicit override for temperature path if auto-discovery fails (UNC Windows path)
if (is.na(temp_path) || !file.exists(temp_path)) {
temp_path <- to_unc(
file.path(
windows_root, "data", "Kaggle Dataset", "11_temperature",
"World_TEMP_GISdata_LTAy_GlobalSolarAtlas-v2_GEOTIFF",
"World_TEMP_GISdata_LTAy_GlobalSolarAtlas_GEOTIFF",
"TEMP.tif"
)
)
}
cat("Resolved temp_path:", temp_path, "exists:", file.exists(temp_path), "\n")
cat("Resolved pop_path :", pop_path,  "exists:", file.exists(pop_path),  "\n")
cat("Resolved veg_path :", veg_path,  "exists:", file.exists(veg_path),  "\n")
cat("Resolved haz_path :", haz_path,  "exists:", file.exists(haz_path),  "\n")
cat("Resolved gdp_path :", gdp_path,  "exists:", file.exists(gdp_path),  "\n")
if (is.na(temp_path) || !file.exists(temp_path)) stop("Temperature raster not found or unreadable; ensure TEMP.tif exists and the path is accessible.")
if (is.na(pop_path)  || !file.exists(pop_path))  stop("Population raster not found or unreadable; ensure GHS_POP...tif exists and the path is accessible.")
env_static <- world %>%
transmute(country_iso) %>%
left_join(
extract_stat(world, temp_path, fun = "mean", fact = 40) %>%
rename(temp_celsius = value),
by = "country_iso"
) %>%
left_join(
extract_stat(world, pop_path, fun = "sum", fact = 60) %>%  # POP is huge
rename(population = value),
by = "country_iso"
) %>%
left_join({
if (file.exists(veg_path)) {
r <- rast(veg_path)
# Align CRS to raster if needed
if (!terra::compareGeom(r, world, stopOnError = FALSE)) {
world_aligned <- st_transform(world, crs(r))
} else {
world_aligned <- world
}
world_aligned$id <- seq_len(nrow(world_aligned))
# Downsample land cover before classifying to save RAM
r <- aggregate(r, fact = 40, fun = median, na.rm = TRUE)
# Classify to a vegetation indicator and average per country
r_veg <- classify(
r,
rbind(
c(-Inf, 10, 0),
c(10, 200, 1),
c(200, Inf, 0)
)
)
z <- terra::zonal(r_veg, vect(world_aligned), fun = "mean", na.rm = TRUE)
frac <- rep(NA_real_, nrow(world_aligned))
frac[match(z$zone, world_aligned$id)] <- z$mean
tibble(country_iso = world_aligned$country_iso, vegetation_fraction = frac)
} else {
warning("Missing land cover raster: ", veg_path)
tibble(country_iso = world$country_iso, vegetation_fraction = NA_real_)
}
}, by = "country_iso") %>%
left_join(
extract_stat(world, haz_path, fun = "mean", fact = 40) %>%
rename(hazard_score = value),
by = "country_iso"
) %>%
mutate(
pm25_mean = NA_real_,
precip_mm_month = NA_real_
)
